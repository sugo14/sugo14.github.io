---
title: "GCC Optimization Pragmas Lie to You"
description: "GCC optimization pragmas do not behave the same as command-line arguments. Why is this?"
slug: "gcc-optim-pragmas"
date: 2024-09-22
---

GCC has many optimization pragmas that can be prepended to files. Generally, they *should* speed up your code the same amount as the equivalent command-line argument, however this is not always the case.

Theoretically, you would expect

```cpp
#pragma GCC optimize("O3")
```

to optimize your code the same way as

```sh
g++ main.cpp -O3
```

But it doesn't! Let's take a look at an example program:

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
using namespace std;

#define SZ 10000005

int arr[SZ] = {};

int main() {
    iota(arr, arr+SZ, 1);
    int tgt = 19999473;
    unordered_set<int> s(arr, arr+SZ);
    for (int i = 0; i < SZ; i++) {
        if (s.count(tgt-arr[i])) {
            cout << arr[i] << ' ' << tgt-arr[i] << '\n';
            break;
        }
    }
}
```

This is a pretty simple and well-known solution to a problem. It solves the Two-Sum problem using a hashset.

Here's a chart showing the runtime of the program with and without the pragma:

|      Optimization    | Time (s) |
|----------------------|----------|
| None, without pragma | ~1.79    |
| None, with pragma    | ~0.98    |
| -O3, without pragma  | ~0.36    |
| -O3, with pragma     | ~0.36    |

As you can see, the pragma does much worse than the `-O3` flag, even though they should be equivalent. Why is this?

Looking into the [assembly code generated](https://godbolt.org/z/cE5j3n4a1), we can see that the code generated by the `-O3` command-line argument actually does not contain **any** occurances of `unordered_set`, whilst the code generated by the pragma contains loads of occurances. What does this mean?

This actually tells us that `-O3` attempts to optimize *all* files, including header files, whilst the pragma only optimizes the source file. Function calls to `unordered_set` are inlined by the compiler when `-O3` is toggled, which explains why they're missing. This means that for situations where your code is only running functions defined within your source file, `#pragma GCC optimize("O3")` would behave the same as `-O3`. However, if your code is heavy on standard library functions, you will notice a big performance hit.

Most of the time, there is no reason to use `#pragma GCC optimize("O3")` over `-O3`, because you can just modify your compile-time command-line arguments. The only place where this is necessary would be competitive programming, since most judges compile with `-O2` and sometimes you're able to squeeze into the time limit by using `O3` and `avx2`. 

So, what have we learned? When using `#pragma` to optimize, make sure that the majority of your code is located within your file, and that you're using less standard library functions. Only then will the optimization pragma be fully useful. 

Thanks for reading my first blog post! I hope you enjoyed!

#### Originally published on [CodeForces](https://codeforces.com/blog/entry/134286).
